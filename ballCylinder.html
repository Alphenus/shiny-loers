<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Making Lörs Lärä Again</title>
        <style>
        </style>

    </head>
    <body>

        <script src="libs/cannon.js"></script>
        <script src="libs/three.min.js"></script>

        <script>
        var hoopRad = 0.5;
        var hoopTube = 0.1;
        var cylRad = 0.35;
        var sphereRad = 0.05;
        var layers = 3;
        var cylH = sphereRad * layers * 2;
        var Vec3 = CANNON.Vec3
        var world, mass, cylMat, hoopMat, sphereBody, hoopBody1, shape, timeStep=1/60,
           camera, scene, renderer, geometry, material, cylMesh, hoopMesh, layers;

        initCannon();
        initThree();
        var rimPosition = new CANNON.Vec3(0.5,0,0);
        var impulse = new CANNON.Vec3(0,1,0);
        hoopBody1.applyImpulse(impulse, rimPosition);
        animate();

        function initCannon() {
            // create world
            world = new CANNON.World();
            world.gravity.set(0,0,-2);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 17;
            world.defaultContactMaterial.contactEquationStiffness = 1e6;
            world.defaultContactMaterial.contactEquationRelaxation = 3;
            world.defaultContactMaterial.friction = 0.3;

            // add friction between cylinder and hoop
            hoopMat = new CANNON.Material("hoopMat");
            cylMat = new CANNON.Material("cylMat");
            var hoopCylContactMaterial = new CANNON.ContactMaterial(hoopMat, cylMat,{
                friction: 0.3,
                restitution: 0,
                contactEquationStiffness: 1000
              });
            world.addMaterial(hoopCylContactMaterial);

            // create hoop
            var cylMass = 10;
            var qCyl = new CANNON.Quaternion();
            var larae = qCyl.setFromAxisAngle(new CANNON.Vec3(1,0,0), Math.PI / 2)
            var hoopShape = new CANNON.Trimesh.createTorus(hoopRad,hoopTube,10,6);
            //cylShape.transformAllPoints(new CANNON.Vec3(),larae);
            hoopBody1 = new CANNON.Body({ mass:cylMass, shape:hoopShape,
                          material:hoopCylContactMaterial });
            //cylBody.addShape(cylShape);
            hoopBody1.position.set(0,0,1);
            world.add(hoopBody1);

            // create some spheres
            sphereBody = new CANNON.Body({ mass:cylMass});
            var sphereShape = new CANNON.Sphere(sphereRad);
            sphereBody.addShape(sphereShape,new CANNON.Vec3(0,0,0));
            var thetas = [];
            for (i = 0; i<7; ++i) {
              thetas.push((2 * Math.PI) * i/7);
            }
            sphereBody.position.set(0,0,layers/2)

            for (zed = -layers/2; zed < layers/2; ++zed) {
              for (j = 0; j < thetas.length; ++j) {
                sphereBody.addShape(sphereShape, new CANNON.Vec3(2*sphereRad*Math.cos(thetas[i]),2*sphereRad*Math.sin(thetas[i]),zed*cylRad*2));
              }
            }

            sphereBody.position.set(0,0,1);
            world.addBody(sphereBody)

            // create base plane
            var groundShape = new CANNON.Plane();
            var groundBody = new CANNON.Body({ mass: 0, shape: groundShape});
            world.add(groundBody);
        }

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 100 );
            camera.position.x = 2;
            camera.position.y = 2;
            camera.position.z = 2;

            camera.rotation.x = -45 * Math.PI / 180;
            camera.rotation.y = 45 * Math.PI / 180;
            camera.rotation.z = (150) * Math.PI / 180;
            scene.add( camera );

            cylGeometry = new THREE.CylinderGeometry( sphereRad*6, sphereRad*6, cylH, 32,32)
            torGeometry = new THREE.TorusGeometry( hoopRad, hoopTube, 16, 128 );
            planeGeometry = new THREE.PlaneGeometry( 2, 2, 32, 32);
            material = new THREE.MeshBasicMaterial( { color: 0xcc5555, wireframe: true } );
            cylGeometry.rotateX( Math.PI / 2)
            cylMesh = new THREE.Mesh( cylGeometry, material );
            hoopMesh = new THREE.Mesh( torGeometry, material );
            planeMesh = new THREE.Mesh( planeGeometry, material );


            scene.add( hoopMesh );
            scene.add( cylMesh );
            scene.add( planeMesh );

            var axisHelper = new THREE.AxisHelper(5);
            scene.add(axisHelper);

            renderer = new THREE.WebGLRenderer();

            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

        }


          function animate() {
              requestAnimationFrame( animate );
              updatePhysics();
              render();
          }

          function updatePhysics() {
              // Step the physics world
              world.step(timeStep);
              // Copy coordinates from Cannon.js to Three.js

              hoopMesh.position.copy(hoopBody1.position);
              hoopMesh.quaternion.copy(hoopBody1.quaternion);
              //cylMesh2.position.copy(cylBody2.position);
              //cylMesh.quaternion.copy(cylBody.quaternion);
              cylMesh.position.copy(sphereBody.position);
              cylMesh.quaternion.copy(sphereBody.quaternion);
            //  console.log("hoop angular velocity: " + hoopBody.angularVelocity);
          }
          function render() {
              renderer.render( scene, camera );
          }

        /*
        var timeStep = 1.0 / 60.0; // seconds
        // make hoop spin
        var rimPosition = new Vec3(1.5,0,0)
        var impulse = new Vec3(0,1,0)
        hoopBody.applyImpulse(impulse,rimPosition)
        // let both fall
        for (var i = 0; i < 60; ++i){
          world.step(timeStep);
          console.log("cylinder position: " + cylBody.position.x,cylBody.position.y,cylBody.position.z);
          console.log("hoop position: " + hoopBody.position.x,hoopBody.position.y,hoopBody.position.z);
          console.log("hoop velocity: " + hoopBody.velocity);
          console.log("hoop angular velocity: " + hoopBody.angularVelocity);
        }
        */
        /*
        // add impulse
        console.log("adding force")
        var imp = new CANNON.Vec3(1,0,0);
        sphereBody.applyForce(imp,sphereBody.position);
        for (var i = 0; i < 10; ++i){
          world.step(timeStep);
          console.log(sphereBody.position.x,sphereBody.position.y,sphereBody.position.z);
        }
        */
        </script>


    </body>
</html>
