<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Making Lörs Lärä Again</title>
        <style>
        </style>

    </head>
    <body>

        <script src="libs/cannon.js"></script>
        <script src="libs/three.min.js"></script>

        <script>
        var world, mass, cylMat, hoopMat, cylBody, cylBody2, hoopBody, shape, timeStep=1/60,
           camera, scene, renderer, geometry, material, cylMesh, cyl2Mesh, hoopMesh, planeMesh,
           cylRad;
        var cylRad = 0.35/2;
        var hoopRad = 0.5;
        var hoopTube = 0.025;
        var Vec3 = CANNON.Vec3;
        initCannon();
        initThree();
        animate();

        function initCannon() {

            // create world
            world = new CANNON.World();
            world.gravity.set(0,0,-1);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 17;
            world.defaultContactMaterial.contactEquationStiffness = 1e6;
            world.defaultContactMaterial.contactEquationRelaxation = 3;
            world.defaultContactMaterial.friction = 0.3;
            /*
            //Create cylinder for stuff
            var cylMass = 10;
            var cylShape = new CANNON.Cylinder(cylRad/1.2,cylRad,1,10);
            cylBody = new CANNON.Body({ mass:cylMass, shape:cylShape });
            cylBody.position.set(0,0,1);
            //cylBody.quaternion.setFromVectors(new CANNON.Vec3(0,1,0), new CANNON.Vec3(0,0,1));
            world.add(cylBody)

            cylBody.collisionResponse = 1; // no impact on other bodys
            cylBody.addEventListener("collide", function(e){ console.log("cylinder collided"); } );
            cylBody.addEventListener("intersect", function(e){ console.log("cylinder collided"); } );

            var cylShape2 = new CANNON.Cylinder(cylRad/1.2,cylRad,1,10);
            cylBody2 = new CANNON.Body({ mass:cylMass, shape:cylShape2 });
            cylBody2.position.set(0,0,3);
            //cylBody2.quaternion.setFromVectors(new CANNON.Vec3(0,1,0), new CANNON.Vec3(0,0,1));
            world.add(cylBody2)


            //Create torus for stuff
            var hoopMass = 1;
            var hoopShape = new CANNON.Trimesh.createTorus(hoopRad,hoopTube,10,6);
            hoopBody = new CANNON.Body({ mass:hoopMass, shape:hoopShape });
            hoopBody.position.set(0,-2,1);
            hoopBody.velocity.set(0,3,0);
            world.add(hoopBody);

            hoopBody.collisionResponse = 1; // no impact on other bodys
            hoopBody.addEventListener("collide", function(e){ console.log("sphere collided"); } );


            //Create Plane for physics
            var groundShape = new CANNON.Plane();
            groundBody = new CANNON.Body({ mass: 0, shape: groundShape});
            groundBody.position.set(0,0,0);

            world.add(groundBody);

            */
        }

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 100 );

            scene.add( camera );
            camera.position.z = 5;

            var axisHelper = new THREE.AxisHelper(3);
            scene.add(axisHelper);

            var cylGeometry = new THREE.CylinderGeometry( cylRad/1.2, cylRad, 1, 32 );
            cylGeometry.rotateX(Math.PI/2);
            cylMaterial = new THREE.MeshBasicMaterial( { color: 0xccFFFF } );

            cylMesh = new THREE.Mesh( cylGeometry, cylMaterial );

            scene.add( cylMesh );

            renderer = new THREE.WebGLRenderer();

            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

        }


          function animate() {
              requestAnimationFrame( animate );
              //updatePhysics();
              render();
          }

          function updatePhysics() {
              // Step the physics world
              world.step(timeStep);
              // Copy coordinates from Cannon.js to Three.js

              /*cylMesh.position.copy(cylBody.position);
              cylMesh.quaternion.copy(cylBody.quaternion);
              cyl2Mesh.position.copy(cylBody2.position);
              cyl2Mesh.quaternion.copy(cylBody2.quaternion);

              hoopMesh.position.copy(hoopBody.position);
              hoopMesh.quaternion.copy(hoopBody.quaternion);*/
              //console.log("hoop angular velocity: " + hoopBody.angularVelocity);

          }
          function render() {
              renderer.render( scene, camera );
          }

        </script>


    </body>
</html>
