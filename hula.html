<!DOCTYPE html>

<html>

	<head>
		<title>hula hoop</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<style>
			body {
				font-family: Monospace;
				background-color: #101010;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			a {
				color: #f00;
			}
		</style>
	<title>hula</title>
	
	<script type="text/javascript" src="libs/three.min.js"></script>
	<script type="text/javascript" src="libs/stats.js"></script>
	<script type="text/javascript" src="libs/physi.js"></script>
		
	<script src="../libs/three.min.js"></script>

	<script src="libs/webvr/controls/VRControls.js"></script>
	<script src="libs/webvr/effects/VREffect.js"></script>
	<script src="libs/webvr/vr/ViveController.js"></script>
	<script src="libs/webvr/vr/WebVR.js"></script>

	<script src="libs/webvr/loaders/OBJLoader.js"></script>
	</head>
	<body>
	
	<script type="text/javascript">
	
	//'use strict';
		
	
	if ( WEBVR.isAvailable() === false ) {
		document.body.appendChild( WEBVR.getMessage() );
	}
		
	var clock = new THREE.Clock();
	
	Physijs.scripts.worker = 'libs/physijs_worker.js';
	Physijs.scripts.ammo = '../libs/ammo.js';
	
	var initScene; 
	var loader;
	var container;
	var ground_material, ground, light; 
	var camera, scene, render, renderer;
	var effect, controls;
	var controller1, controller2;
		
		
	initScene();
	animate();
	
	function initScene() {
		
		container = document.createElement( 'div' );
		document.body.appendChild( container );
		
		renderer = new THREE.WebGLRenderer({ antialias: true });
		//renderer.setSize( window.innerWidth, window.innerHeight );
		//renderer.shadowMap.enabled = true;
		//renderer.shadowMapSoft = true;
		renderer.setClearColor( 0x505050 );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.sortObjects = false;
		container.appendChild( renderer.domElement );
		
		/*
		render_stats = new Stats();
		render_stats.domElement.style.position = 'absolute';
		render_stats.domElement.style.top = '0px';
		render_stats.domElement.style.zIndex = 100;
		document.getElementById( 'viewport' ).appendChild( render_stats.domElement );
		
		physics_stats = new Stats();
		physics_stats.domElement.style.position = 'absolute';
		physics_stats.domElement.style.top = '50px';
		physics_stats.domElement.style.zIndex = 100;
		document.getElementById( 'viewport' ).appendChild( physics_stats.domElement );
		*/

		scene = new Physijs.Scene;
		
		//scene.setGravity(new THREE.Vector3( 0, -9.82, 0 ));
		scene.setGravity(new THREE.Vector3( 0, -0.5, 0 ));
		
		scene.addEventListener(
			'update',
			function() {
				scene.simulate( undefined, 1 );
			}
		);
		
		camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 10 );
		/*
		camera = new THREE.PerspectiveCamera(
			35,
			window.innerWidth / window.innerHeight,
			1,
			1000
		);
		*/
		
		scene.add( camera );
		
		// Light -- ignoring for now
		/*
		light = new THREE.DirectionalLight( 0xFFFFFF );
		light.position.set( 20, 40, -15 );
		light.target.position.copy( scene.position );
		light.castShadow = true;
		light.shadowCameraLeft = -60;
		light.shadowCameraTop = -60;
		light.shadowCameraRight = 60;
		light.shadowCameraBottom = 60;
		light.shadowCameraNear = 20;
		light.shadowCameraFar = 200;
		light.shadowBias = -.0001
		light.shadowMapWidth = light.shadowMapHeight = 2048;
		light.shadowDarkness = .7;
		scene.add( light );
		*/

		// Loader
		loader = new THREE.TextureLoader();
		
		room = new THREE.Mesh(
			new THREE.BoxGeometry( 6, 6, 6, 8, 8, 8 )
		);
		
		scene.add( room );
		
		//TODO: figure out lighting ...
		scene.add( new THREE.HemisphereLight( 0x606060, 0x404040 ) );
		
		var light = new THREE.DirectionalLight( 0xffffff );
		light.position.set( 1, 1, 1 ).normalize();
		scene.add( light );
	
		// Ground
		ground_material = Physijs.createMaterial(
			//new THREE.MeshLambertMaterial({ map: loader.load( 'images/rocks.jpg' ) }),
			new THREE.MeshBasicMaterial({color : 0x404040}),
			.8, // high friction
			.3 // low restitution
		);
		
		ground = new Physijs.BoxMesh(
			new THREE.BoxGeometry(10, 1, 10),
			ground_material,
			0 // mass
		);
		
		ground.receiveShadow = true;
		scene.add( ground );
		
		hoopRadius = 1.0 / 2; // in m
		hoopTubeRadius = 1.1 / 100 / 2;
		
		/* TODO: TORUS SHAPE FROM THIS MODEL, attach to simulation
				// see:
				// https://threejs.org/docs/api/textures/Texture.html
				// https://solutiondesign.com/blog/-/blogs/webgl-and-three-js-texture-mappi-1/
				var torusTex = new THREE.TextureLoader().load("hula-tex.png");
				torusTex.wrapS = THREE.RepeatWrapping;
				torusTex.wrapT = THREE.RepeatWrapping;
				torusTex.repeat.set(4,4);
				
				var torus = new THREE.Mesh(
					new THREE.TorusGeometry(
						1.0 / 2, // radius (in m)
						1.1 / 100, // diameter of tube
						16, // no. of radial segments
						128 // no. of tubular segments
					),
					new THREE.MeshBasicMaterial(
						//{ color: 0xffa3fd }
						{ map: torusTex }
					)
				);
				
				//torus.position.y = -3;
				torus.position.y = 1.1;
				torus.rotation.x = Math.PI / 2;
				
				room.add(torus);
		
		*/
			
		//var nSegments = 2;
		var nSegments = 16;
		
		var hoopMass = 1;
		
		getTorusSegment = function(
			idx = 0,
			l = Math.PI * 2 * hoopRadius / nSegments,
			w = hoopTubeRadius, 
			m = hoopMass / nSegments
			) {
			var s = new Physijs.BoxMesh(
				new THREE.BoxGeometry(
					w, w,
					l
				),
				Physijs.createMaterial(
					new THREE.MeshBasicMaterial(
						{color: 0xffa3fd}
					),
					0.6,
					0.3
				)
			);
			
			//s.mass = m;
			
			var theta = idx * Math.PI * 2 / nSegments + Math.PI / 2;
			
			s.position.x = Math.sin(theta) * hoopRadius;
			s.position.z = Math.cos(theta) * hoopRadius;
			
			s.rotateY(theta + Math.PI / 2);
			
			return s;
		}
		
		//torusCenter = getTorusSegment();
		torusCenter =  new Physijs.BoxMesh(
			new THREE.BoxGeometry(
				//hoopRadius / 2, hoopRadius / 5,  hoopRadius / 2
				0,0,0
				///1000, 1000, 1000
			),
			Physijs.createMaterial(
					new THREE.MeshBasicMaterial(
						{color: 0xffa3fd}
					),
					0.6,
					0.3
			)
		);
		
		torusCenter.mass = 1;
		torusCenter.position.y = 2;
		
		torusCenter.rotateX(0.5);

		for(var i = 0; i < nSegments; i++) {
			torusCenter.add(getTorusSegment(idx = i));
		}
		
		//room.add(torusCenter);
		scene.add(torusCenter);
		
		cylinder = new Physijs.CylinderMesh(
			new THREE.CylinderGeometry(
				0.35 / 2, 0.35 / 2,
				1,
				64
			),
			Physijs.createMaterial(
				new THREE.MeshBasicMaterial(
					{color: 0xababab}
				),
				0.6,
				0.3
			)
		);
		
		cylinder.mass = 1;
		cylinder.receiveShadow = true;
		
		cylinder.position.y = 2;
		cylinder.position.x = 0.25;
		//cylinder.rotateX(1);
		
		scene.add(cylinder);
		
		// vive controller blocks // TODO
		/*
				// blocks for the cnotrollers ('hips')
				block1Pivot = new THREE.Group();
				block2Pivot = new THREE.Group();
				
				block1 = new THREE.Mesh(
					new THREE.BoxGeometry(
						0.1, 0.5, 0.05
					),
					new THREE.MeshBasicMaterial( {color: 0xababab , opacity : 0.5, transparent: true})
				) 
				block2 = new THREE.Mesh(
					new THREE.BoxGeometry(
						0.1, 0.5, 0.05
					),
					new THREE.MeshBasicMaterial( {color: 0xababab , opacity : 0.5, transparent: true})
				) 
				
				block1.rotateX(Math.PI / 2);
				block2.rotateX(Math.PI / 2);
				
				room.add(block1Pivot);
				room.add(block2Pivot);
				
				block1Pivot.add(block1);
				block2Pivot.add(block2);
		*/
		
		
	room.add(new THREE.AxisHelper(1));
		
	// VR STUFF
		
	controls = new THREE.VRControls( camera );
	controls.standing = true;

	controller1 = new THREE.ViveController( 0 );
	controller1.standingMatrix = controls.getStandingMatrix();
	scene.add( controller1 );

	controller2 = new THREE.ViveController( 1 );
	controller2.standingMatrix = controls.getStandingMatrix();
	scene.add( controller2 );
		
	var loader = new THREE.OBJLoader();
	loader.setPath( 'models/obj/vive-controller/' );
	loader.load( 'vr_controller_vive_1_5.obj', function ( object ) {

		var loader = new THREE.TextureLoader();
		loader.setPath( 'models/obj/vive-controller/' );

		var controller = object.children[ 0 ];
		controller.material.map = loader.load( 'onepointfive_texture.png' );
		controller.material.specularMap = loader.load( 'onepointfive_spec.png' );

		controller1.add( object.clone() );
		controller2.add( object.clone() );

	} );

	effect = new THREE.VREffect( renderer );

	if ( WEBVR.isAvailable() === true ) {

		var b = WEBVR.getButton( effect );
		document.body.appendChild( b );
		
	}

		window.addEventListener( 'resize', onWindowResize, false );
		
		requestAnimationFrame( render );
		scene.simulate();
	};
	
	function animate() {
		effect.requestAnimationFrame( animate );
		
		
		render();
		
	}
	function render() {
		//requestAnimationFrame( render );
		//renderer.render( scene, camera );
		
				//scene.simulate();
		
				var delta = clock.getDelta() * 60;

				controller1.update();
				controller2.update();

				controls.update();
				
				var p1 = controller1.getWorldPosition();
				var r1 = controller1.getWorldRotation();
				
				var p2 = controller2.getWorldPosition();
				var r2 = controller2.getWorldRotation();
				
		/*
				block1Pivot.position.copy(p1);
				block2Pivot.position.copy(p2);
				
				block1Pivot.setRotationFromEuler(r1);
				block2Pivot.setRotationFromEuler(r2);
				
				*/
				effect.render( scene, camera );
	};
	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		effect.setSize( window.innerWidth, window.innerHeight );

	}
		

	
	
	//window.onload = initScene;
	
	</script>

</body>

</html>